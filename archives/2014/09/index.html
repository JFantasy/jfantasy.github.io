<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>Archives: 2014/9 | JFantasy&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="jfantasy">
  
  
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="JFantasy's Blog">
<meta property="og:url" content="http://yoursite.com/archives/2014/09/">
<meta property="og:site_name" content="JFantasy's Blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JFantasy's Blog">
<meta name="twitter:description">

  
    <link rel="alternate" href="/atom.xml" title="JFantasy&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">JFantasy&#39;s Blog</a></h1>
    <p><a href="/"></a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/about">About</a></li>
      
      
        <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content">


<h2 class="archives-title"><span>2014</span></h2>



  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2014/09/03/em算法的一些理解/">
  <time datetime="2014-09-03T06:54:50.000Z">
    Sep 3 2014
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2014/09/03/em算法的一些理解/">EM算法的一些理解</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>最近由于课程关系读了一下prml中关于<a href="http://en.wikipedia.org/wiki/Expectation–maximization_algorithm" target="_blank" rel="external">EM</a>的章节，虽然以前对这个算法已经有一些了解，但在从prml中又更深刻地理解了一番，决定写点笔记来巩固一下。</p>
<h3 id="问题描述">问题描述</h3>
<p>一句话的解释就是：<strong>对存在隐含变量的概率分布进行参数估计</strong><br>直观来说，一般概率分布的估参问题里面的变量都是可见的，比如估算硬币丢一次出现正面的概率，这个正面或者反面就是在多次实验中出现的变量，我们可以利用这些结果来估算这个概率。<br>而那些存在隐含变量的问题，我们可以把上面的问题改成，现在有三个硬币（已经编号），我首先会固定的拿第一个硬币丢一次，如果出现正面我就选择第二个硬币，否则选择第三个硬币，接着用选择的硬币丢一次作为结果，现在要求出现正面的概率，在这个场景下，同样我们可以多次实验，但是我们设定第一个硬币的结果是不会被记录下来，只记录第二次硬币的结果，即第一个硬币用于选择完以后就被遗忘了。这个时候第一个硬币的结果就称为<strong>隐含变量</strong>，因为它对我们来说是不可见的。<br>总的来说，EM就是用来解决这一类问题，接下来会来说明为什么传统简单粗暴的估参方法为什么行不通而需要EM。</p>
<h3 id="传统方法的局限">传统方法的局限</h3>
<p>首先我们定义$X$作为我们要估算的那个事件，$\theta$作为这个概率分布函数的参数，<br>则$X$发生的概率可记录为$P(X;\theta)$ <strong>($\theta$表示这个概率分布的所有参数，所有的概率分布最终要转化成数值都必须经过它，最终我们要得到的也是这个$\theta$，在后面的表示中，为了方便，将$\theta$省略)</strong><br>此时，由于存在隐含变量，假设我们把它定义为$Z$，那么  </p>
<ul>
<li>$P(X,Z)$ 表示隐含事件Z和可见事件X同时发生了的概率(比如例子中，第一个硬币得到了正面，这是变量$Z$，第二个硬币得到了反面，这是变量$X$，这个就叫做同时发生)</li>
<li>$P(X|Z)$ 表示隐含事件Z已经发生的前提下，事件X发生了的概率(比如例子中，第一个硬币得到了正面，这个时候我们只关注第二个硬币到底是正还是反，不关心第一个硬币的情况，因为我们已经知道它使得我们选择了第二个硬币)</li>
<li>同时我们有 $P(X)=\sum_{k=1}^{Z}P(X,z_k)$ </li>
</ul>
<p>有了以上这几点，我们可以尝试用传统的极大似然法来求最值，即最大化$\sum_{n=1}^{N}lnP(x_n)$<br>同时我们有 $P(X)=\sum_{k=1}^{Z}P(X,z_k)$<br>则可以变成最大化$\sum_{n=1}^{N}ln\sum_{k=1}^{Z}P(x_n,z_k)$</p>
<p>按照极大似然的步骤，下一步就是对它进行求导等于零。<br><strong>但此时我们会发现，由于$ln$里面存在加法导致无法很容易地直接得到解析解。</strong><br><strong>而EM正是用来解决这一个问题。</strong></p>
<h3 id="EM的一般步骤">EM的一般步骤</h3>
<p><strong>在这个章节中会介绍EM算法的步骤，为了叙述方便，本节不会说明这个做法的数学证明，有一些步骤如果没有说明暂且认为是对的，其更本质更底层的解释会在下一节进行。</strong>  </p>
<p>由于上节我们发现$\sum_{n=1}^{N}ln\sum_{k=1}^{Z}P(x_n,z_k)$没办法直接通过极大似然的方法求出最大值，为了接下来的步骤，首先我们要做几个定义：</p>
<ul>
<li>对于任意一个事件$X$，实际上都有一个对应的$Z$，我们把$(X,Z)$这样一个pair称之为完整数据，但在我们的问题中，是没办法得到$Z$的</li>
<li>对于当前的完整数据，它的$Z$必然是服从一个分布的，由于我们已经有$X$的数据，我们可以用$X$来算出这些事件发生下，$Z$的一个后验分布，即$P(Z|X)$</li>
<li>$P(z_k|X)$的值可以这么得到<br>$$P(z_k|X)=\frac{P(z_k)P(X|z_k)}{\sum_{j=1}^{K}P(z_j)P(X|z_j)}$$</li>
</ul>
<p>接着我们不直接求$\sum_{n=1}^{N}lnP(x_n)$的最大值，转而求$\sum_{n=1}^{N}lnP(x_n)$在$P(Z|X)$分布下的期望的最大值，即<br>$$\sum_{n=1}^{N}\sum_{k=1}^{Z}P(z_k|x_n)lnP(x_n,z_k)$$<br><strong>(这样做的正确性会在下一节给出说明，现在暂且认为是对的)</strong></p>
<p>当最大化的目标变成$\sum_{n=1}^{N}\sum_{k=1}^{Z}P(z_k|X)lnP(x_n,z_k)$，那么$ln$之中的加法也不见了，于是就可以求导等于零的方法来求一组使得目标最大化的$\theta$，这个就是EM的一轮迭代，由于一轮迭代以后$\theta$已经发生了变化，则意味着$P(Z|X)$也必须发生变化，所以又可以重新计算$P(Z|X)$然后继续求新的一组最大化目标的参数，直至收敛。<br>综上所述，我们可以得到EM的一般步骤：  </p>
<ul>
<li>E步：根据当前的$\theta$计算$P(Z|X)$</li>
<li>M步：$\theta = argmax\sum_{n=1}^{N}\sum_{k=1}^{Z}P(z_k|x_n)lnP(x_n,z_k)$</li>
<li>不断重复迭代，直至收敛</li>
</ul>
<p>这个做法为什么是可行的以及中间关于求期望最大的说明，接下来会从两个不同的角度来说明这个问题。</p>
<h3 id="从Jensen不等式的角度解释">从Jensen不等式的角度解释</h3>
<p>首先从<a href="http://en.wikipedia.org/wiki/Jensen%27s_inequality" target="_blank" rel="external">Jensen不等式</a>讲起，它的内容是这样的: <strong>如果$f$是凸函数，X是随机变量，那么 $E[f(X)] \ge f(E[X])$，反之如果是凹函数，那么$f(E[X]) \ge E[f(x)]$；同时等号成立当且仅当$P(X=E[X])=1$，即$X$等于一个常数。</strong> 这个不等式及其性质在后续的证明中会用到。<br>回到最初的那个式子$\sum_{n=1}^{N}ln\sum_{k=1}^{Z}P(x_n,z_k)$，同样的我们可以用$Q_n(Z)$来代表Z的分布，则式子又可以变成<br>$$\sum_{n=1}^{N}ln\sum_{k=1}^{Z}P(x_n,z_k)=<br>\sum_{n=1}^{N}ln\sum_{k=1}^{Z}Q_n(z_k)\frac{P(x_n,z_k)}{Q_n(z_k)}$$<br>此时，我们可以令$f=ln$，由于ln是凹函数，由Jensen不等式得<br>$$\sum_{n=1}^{N}ln\sum_{k=1}^{Z}Q_n(z_k)\frac{P(x_n,z_k)}{Q_n(z_k)} \ge \sum_{n=1}^{N}\sum_{k=1}^{Z}Q_n(z_k)ln\frac{P(x_n,z_k)}{Q_n(z_k)}$$<br>于是我们可以得到$\sum_{n=1}^{N}\sum_{k=1}^{Z}Q_n(z_k)ln\frac{P(x_n,z_k)}{Q_n(z_k)}$是原优化目标的一个下界。<br>于是我们可以得到这样一个策略：不断的调整参数使得它的下界上升，则目标函数也会跟着上升。同时，我们希望这个等号能够成立，当等号成立说明当前得到的这个值已经就是要优化的目标函数值了。<br>而等号是否成立跟目标函数值是无关的，只跟$Q_n(z_k)$有关，考虑Jensen不等式的等号成立条件，我们可以得到<br>$$\frac{P(x_n,z_k)}{Q_n(z_k)}=c$$<br>由于$Q_n(z_k)$是Z的一个分布，则有$\sum_{k=1}^{Z}Q_n(z_k)=1$，那么$\sum_{k=1}^{Z}P(x_n,z_k)=c$<br>则有<br>$$Q_n(z_k)$$<br>$$=\frac{P(x_n,z_k)}{c}$$<br>$$=\frac{P(x_n,z_k)}{\sum_{k=1}^{Z}P(x_n,z_k)}$$<br>$$=P(z_k|x_n)$$<br>综上所述，当$Q_n(z_k)=P(z_k|x_n)$的时候，等号成立。<br>于是我们可以再一次得到EM的步骤：</p>
<ul>
<li>E步：令$Q_n(z_k)=P(z_k|x_n)$</li>
<li>M步：$\theta = argmax\sum_{n=1}^{N}\sum_{k=1}^{Z}Q_n(z_k)ln\frac{P(x_n,z_k)}{Q_n(z_k)}$</li>
</ul>
<p>当我们把$Q_n(z_k)=P(z_k|x_n)$代入之后，由于$Q_n(z_k)$已经不变，我们可以把$ln$的分子作为常数，即<br>$$\theta = argmax\sum_{n=1}^{N}\sum_{k=1}^{Z}P(z_k|x_n)lnP(x_n,z_k) - const$$<br>$$=argmax\sum_{n=1}^{N}\sum_{k=1}^{Z}P(z_k|x_n)lnP(x_n,z_k)$$<br>这个时候与上节的优化目标就一致了。</p>
<h3 id="从Kullback–Leibler的角度来解释">从Kullback–Leibler的角度来解释</h3>
<p>首先要看一下<a href="http://en.wikipedia.org/wiki/Kullback–Leibler_divergence" target="_blank" rel="external">Kullback–Leibler divergence</a>的定义，它用于衡量两个概率分布之间的距离。<br>依然从最原始的优化目标$\sum_{n=1}^{N}ln\sum_{k=1}^{Z}P(x_n,z_k)$出发，同样的，我们仿造上一节用一个$Q(Z)$表示Z的分布，则<br>$$lnP(X)=\mathcal{L}(Q)+KL(Q||P)$$<br>其中<br>$$\mathcal{L}(Q)=\sum_{k=1}^{Z}Q(z_k)ln\frac{P(X,z_k)}{Q(z_k)} \qquad KL=-\sum_{k=1}^{Z}Q(z_k)ln\frac{P(z_k|X)}{Q(z_k)}$$<br>由$KL$的定义有$KL \ge 0$，等号成立当且仅当$P=Q$。<br>从这里可以看出，实际上Jensen不等式跟Kullback–Leibler的角度的本质是一样的，那个不等号缺少的部分实际就是$KL$距离。<br>接着再解释一下每一次迭代对优化函数的影响：  </p>
<ul>
<li>在每一次迭代中，E步首先令$Q=P$这个时候，对目标函数的值是没有影响的，因为只有参数$\theta$才会改变目标函数的值，而$Q$只是我们假设出来的分布而已，E步的作用在于把下界提升，使得它跟当前的目标函数值相等。  </li>
<li>M步才是改变$\theta$的，由于我们对当前这个下界求了最大值，必然的此时$P$和$Q$又不一样了，即$KL&gt;0$，所以可以知道目标函数值也跟着上升了。</li>
</ul>
<p>综上所述，EM的步骤就是不断提升下界，同时因为下界和目标函数值之间永远差了一个$KL$，所以也提升了目标函数值。</p>
<h3 id="写在最后的话">写在最后的话</h3>
<p>写完了，好长。<br>之前参考过这么一篇，其中从Jensen不等式的角度来解释，作者讲得超级好，醍醐灌顶，而且有图，强力推荐。 <a href="http://www.cnblogs.com/jerrylead/archive/2011/04/06/2006936.html" target="_blank" rel="external">传送门</a></p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  

  <nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav>

</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2014 <a href="/">jfantasy</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
  var duoshuoQuery = { short_name: 'jfantasy90' };
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';
    ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
inlineMath: [ ['$','$'], ["\\(","\\)"] ],
processEscapes: true
}
});
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
}
});
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
    }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


</body>
</html>